import pandas as pd 
import numpy as np
from darts import TimeSeries
from darts.models import RegressionModel, LightGBMModel
from darts.metrics import mape, mae, ope, mase
from sklearn.linear_model import BayesianRidge
from aeml.models.gbdt.gbmquantile import LightGBMQuantileRegressor
from aeml.models.gbdt.run import run_ci_model, run_model
from aeml.models.gbdt.settings import *
from aeml.models.gbdt.plot import make_forecast_plot


from darts.dataprocessing.transformers import Scaler
import joblib, pickle, subprocess

import matplotlib.dates as mdates
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

plt.style.reload_library()
plt.style.use('grid')

from matplotlib import rcParams
rcParams['font.family'] = 'DejaVu Sans'

from chronos import ChronosPipeline
import torch
from transformers import set_seed
from datetime import datetime
import os

"""
# =============================================================================
Script Name: PlotHistoricalForecast.py
Author(s) <Abrevation>: Amir Elahi <AE>
Date: 8 April 2022

TL;DR:
    This script is used to plot the output pickle files generated by ModelTrain_Chronos.py.

Description:
    < >.

Usage:
    Plot the historical forecast generated by ModelTrain_Chronos.py.

Dependencies:
    Refer to the *.yml file based on your operating system.

Notes:
    < >.

#TODO:
    < >.

Version History:
    <Date>, <Author>, <Description of Changes>
    6  April 2022 AE Add the historical forecast and averaging of the data using Chronos model.
    8  April 2022 AE Configure the plotting and saving of the output. Adding flags to make it easier to use.
    14 April 2022 AE Add the MAE calculation and plotting.
# =============================================================================
"""

# =============================================================================
# Load the data
df = pd.read_pickle('/home/lsmo/Desktop/aeml_project/aeml/DataDynamo/RawData/New_campaigns/202403 SCOPE data set dynamic campaign.pkl')

df = df.dropna()

TARGETS_clean = ['AMP-4', 'PZ-4'] 

MEAS_COLUMNS = [
     'TI-3',
     'TI-35',
     'F-11',
     'F-19',
     'T-19']

# =============================================================================
# Convert to TimeSeries and scale the data
y = TimeSeries.from_dataframe(df, value_cols=TARGETS_clean, time_col='Date')
x = TimeSeries.from_dataframe(df, value_cols=MEAS_COLUMNS, time_col='Date')

transformer = Scaler()
x = transformer.fit_transform(x)

y_transformer = Scaler()
y = y_transformer.fit_transform(y)

scal = y_transformer.transform(y)

# Calculate the average of the time series
average = np.mean(y_transformer.inverse_transform(y)[TARGETS_clean[0]].values())

# Print the average
print(f'Average {average}')

# =============================================================================
# Some constant values for naming, saving the files and plotting
prediction_length = 64
startPoint = 0
endPoint = len(y)
skip = 48

commit_id = 'c7071ee'
date_string = '08042024_041232'
output_path = os.getcwd() + '/DataDynamo/Output/'

def average_timeseries(y, startPoint, endPoint, skip):
    averaged_values = []
    for i in range(startPoint, endPoint, skip):
        avg = sum(y.values()[i:i+skip]) / skip
        averaged_values.append(avg)
    return averaged_values

Ts3 = average_timeseries(y, startPoint, endPoint, skip)
Ts3 = TimeSeries.from_times_and_values(times = y[startPoint:endPoint:skip].time_index, values = Ts3)
Ts3 = Ts3.pd_dataframe()
Ts3.columns = y.pd_dataframe().columns
Ts3 = TimeSeries.from_dataframe(Ts3)

# =============================================================================
# Reading the historical forecast outputs generated by ModelTrain_Choronos.py
# Read the lists from the files
with open(output_path + f'{commit_id}_FullForecast_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullForecast_df = pickle.load(f)
with open(output_path + f'{commit_id}_FullLow_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullLow = pickle.load(f)
with open(output_path + f'{commit_id}_FullHigh_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullHigh = pickle.load(f)

FullForecast = [TimeSeries.from_dataframe(df) for df in FullForecast_df]

# Which prediction point in histoical forecast to get and plot. from 0 to len(FullForecast[0]) - 1
prediction_point = len(FullForecast[0]) - 1
prediction_time = (prediction_point + 1) * skip * 10 / 60 # In minutes

# Extract the first point of each time series
point_selected_values = [ts.values()[prediction_point] for ts in FullForecast]
point_selected_times = [ts.time_index[prediction_point] for ts in FullForecast]

# Create a new time series from the first points
point_selected_ts = TimeSeries.from_times_and_values(pd.DatetimeIndex(point_selected_times), point_selected_values)

point_selected_values_Low = [array[prediction_point] for array in FullLow]
point_selected_values_High = [array[prediction_point] for array in FullHigh]

#* Inverse Transforming the series
Ts3 = y_transformer.inverse_transform(Ts3)

# =============================================================================
# Calculate the MAE for the model
mae_value = []
prediction_time_for_mae = []
for i in range(0,len(FullForecast[0])):
    ts_values_for_mae = [ts.values()[i] for ts in FullForecast]
    ts_times_for_mae = [ts.time_index[i] for ts in FullForecast]
    ts_for_mae = TimeSeries.from_times_and_values(pd.DatetimeIndex(ts_times_for_mae), ts_values_for_mae)
    prediction_time_for_mae.append((i + 1) * skip * 10 / 60 / 60) # In hours
    # mae_value.append(mae(actual_series = ts_for_mae, pred_series = FullForecast[i], intersect = True))
    mae_value.append(mae(actual_series = Ts3[TARGETS_clean[0]], pred_series = ts_for_mae, intersect = True))

mae_value = [(value / average) for value in mae_value]
'''Plotting'''
# =============================================================================
# Plot the time series
fig = plt.figure(figsize=(3.5*3, 3.5*3))
fig.subplots_adjust(bottom=0.2, left= 0.15)


# Ts3[TARGETS_clean[0]][startPoint:endPoint].plot(label=f'True values averaging every {skip - 1} points')
# Ts3[TARGETS_clean[0]][startPoint:startPoint + 512].plot(label=f'First 512 true values')

# point_selected_ts.plot(label=f'Historical forecast with {prediction_time} minutes in future')
# plt.fill_between(point_selected_times, point_selected_values_Low, point_selected_values_High, color="tomato", alpha=0.3, label="80% prediction interval")

plt.plot(prediction_time_for_mae, mae_value ,label='Mean absolute error [MAE] / Average')

# Get the current Axes instance on the current figure
ax = plt.gca()

# Set the x-axis scale to logarithmic
ax.set_xscale('log')

'''Plot Information and decoration'''
# =============================================================================
# Setting the font properties
plt.rcParams['font.family'] = 'sans-serif'

fpLegend = '/home/lsmo/.local/share/fonts/calibri-regular.ttf'
fpLegendtitle = '/home/lsmo/.local/share/fonts/coolvetica rg.otf'
fpTitle = '/home/lsmo/.local/share/fonts/coolvetica rg.otf'
fpLabel = '/home/lsmo/.local/share/fonts/Philosopher-Bold.ttf'
fpTicks = '/home/lsmo/.local/share/fonts/Philosopher-Regular.ttf'

fLegend = FontProperties(fname=fpLegend, size = 13)
fLegendtitle = FontProperties(fname=fpLegendtitle, size = 14)
fTitle = FontProperties(fname=fpTitle, size = 18)
fLabel = FontProperties(fname=fpLabel, size = 16)
fTicks = FontProperties( size = 15)

# =============================================================================
# Add labels and title and ticks
# plt.ylabel(r'Emissions $[\mathrm{mg/nm^3}]$', fontproperties = fLabel)
# plt.xlabel('Date', fontproperties = fLabel)

plt.ylabel('Mean absolute error [MAE] / Average', fontproperties = fLabel)
plt.xlabel('Log scale forecasting horizon [hours]', fontproperties = fLabel)

adsorbent_in_plot = r'2-Amino-2-methylpropanol $(\mathrm{C_4H_{11}NO})$'
plt.title( f'{adsorbent_in_plot}'
          , fontproperties = fTitle)

for label in (plt.gca().get_xticklabels() + plt.gca().get_yticklabels()):
    label.set_fontproperties(fTicks)

# =============================================================================
# Add a frame around the plot area
plt.gca().spines['top'].set_visible(True)
plt.gca().spines['right'].set_visible(True)
plt.gca().spines['bottom'].set_visible(True)
plt.gca().spines['left'].set_visible(True)

# =============================================================================
# Add a legend
legend = plt.legend(fontsize = 12, prop = fLegend)
legend.set_title('Legend', prop = fLegendtitle)

# =============================================================================
# Set the date format
# date_format = mdates.DateFormatter('%b-%d')
# plt.gca().xaxis.set_major_formatter(date_format)

# =============================================================================
# Adjust font size for tick labels
# plt.xticks(rotation='vertical', fontproperties = fTicks)
plt.xticks(fontproperties = fTicks)
plt.yticks(fontproperties = fTicks)
# =============================================================================

plt.show()