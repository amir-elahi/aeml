import pandas as pd 
import numpy as np
from darts import TimeSeries
from darts.metrics import mape, mae, ope, mase
from sklearn.linear_model import BayesianRidge

from darts.dataprocessing.transformers import Scaler
import joblib, pickle, subprocess

from datetime import datetime
import os


from aeml.utils.Plot import *
from aeml.utils.metrics import get_metrics

"""
# =============================================================================
Script Name: PlotHistoricalForecast.py
Author(s) <Abrevation>: Amir Elahi <AE>
Date: 8 April 2022

TL;DR:
    This script is used to plot the output pickle files generated by ModelTrain_Chronos.py.

Description:
    < >.

Usage:
    Plot the historical forecast generated by ModelTrain_Chronos.py.

Dependencies:
    Refer to the *.yml file based on your operating system.

Notes:
    < >.

#TODO:
    < >.

Version History:
    <Date>, <Author>, <Description of Changes>
    6  April 2022 AE Add the historical forecast and averaging of the data using Chronos model.
    8  April 2022 AE Configure the plotting and saving of the output. Adding flags to make it easier to use.
    14 April 2022 AE Add the MAE calculation and plotting.
    17 April 2022 AE Read the prediction_length instead of hardcoding it.
# =============================================================================
"""

# =============================================================================
# Load the data
df = pd.read_pickle('/home/lsmo/Desktop/aeml_project/aeml/DataDynamo/RawData/New_campaigns/202403 SCOPE data set dynamic campaign.pkl')

df = df.dropna()

df['TI-1213'] = np.where(df['valve position'] == 1, df['TI-13'], df['TI-12'])

TARGETS_clean = ['AMP-4', 'PZ-4'] 

MEAS_COLUMNS = [ 'T-19', 'TI-3', 'F-19','F-11', 'TI-1213','TI-35']



# =============================================================================
# Pickle names and paths
commit_id = 'c7071ee'
date_string = '08042024_041232'
Model='Tiny_Model'
output_path = os.getcwd() + f'/DataDynamo/Output/{Model}/'
skip = 48

# =============================================================================
# Reading the historical forecast outputs generated by ModelTrain_Choronos.py
# Read the lists from the files
with open(output_path + f'{commit_id}_FullForecast_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullForecast_df = pickle.load(f)
with open(output_path + f'{commit_id}_FullLow_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullLow = pickle.load(f)
with open(output_path + f'{commit_id}_FullHigh_{date_string}_Skip{skip}.pkl', 'rb') as f:
    FullHigh = pickle.load(f)

FullForecast = [TimeSeries.from_dataframe(df) for df in FullForecast_df]

# =============================================================================
# Convert to TimeSeries and scale the data
y = TimeSeries.from_dataframe(df, value_cols=TARGETS_clean, time_col='Date')
x = TimeSeries.from_dataframe(df, value_cols=MEAS_COLUMNS, time_col='Date')

transformer = Scaler()
x = transformer.fit_transform(x)

y_transformer = Scaler()
y = y_transformer.fit_transform(y)

scal = y_transformer.transform(y)

# Calculate the average of the time series
average = np.mean(y_transformer.inverse_transform(y)[TARGETS_clean[0]].values())

# =============================================================================
# Some constant values for naming, saving the files and plotting
prediction_length = len(FullForecast[0])
startPoint = 0
endPoint = len(y)

# =============================================================================
# Print some useful information
print(f'Average of the whole dataset: {average}') # Print the average
print(f'Prediction length: {prediction_length}') # Print the prediction length

def average_timeseries(df, skip):
    return df.rolling(window=skip, min_periods=1).mean()[::skip]

# Convert TimeSeries to DataFrame for processing
df_y = y.pd_dataframe()
df_x = x.pd_dataframe()

# Apply averaging function
temp_y = average_timeseries(df_y, skip)
temp_y.columns = y.pd_dataframe().columns
ts_y = TimeSeries.from_dataframe(temp_y)
df_y= temp_y

y = ts_y

temp_x = average_timeseries(df_x, skip)
temp_x.columns = x.pd_dataframe().columns
ts_x = TimeSeries.from_dataframe(temp_x)
df_x = temp_x

x = ts_x

Ts3 = y

# =============================================================================
# Extract the prediction point from the historical forecast
# Which prediction point in histoical forecast to get and plot. from 0 to len(FullForecast[0]) - 1
prediction_point = len(FullForecast[0]) - 1
prediction_time = (prediction_point + 1) * skip * 10 / 60 # In minutes

# Extract the point of each time series
point_selected_values = [ts.values()[prediction_point] for ts in FullForecast]
point_selected_times = [ts.time_index[prediction_point] for ts in FullForecast]

# Create a new time series from the points
point_selected_ts = TimeSeries.from_times_and_values(pd.DatetimeIndex(point_selected_times), point_selected_values)

point_selected_values_Low = [array[prediction_point] for array in FullLow]
point_selected_values_High = [array[prediction_point] for array in FullHigh]


point_selected_df = point_selected_ts.pd_dataframe()
point_selected_df.columns = [TARGETS_clean[0]]
point_selected_df.index.name = 'Date'

y_forecast = TimeSeries.from_dataframe(point_selected_df)

#* Inverse Transforming the series
y_actual = y_transformer.inverse_transform(Ts3)
x_actual = transformer.inverse_transform(x)

# =============================================================================
# Calculate the MAE for the model
y_forecast_list = []
time_horizon = []
for i in range(0,len(FullForecast[0])):
    ts_values = [ts.values()[i] for ts in FullForecast]
    ts_times = [ts.time_index[i] for ts in FullForecast]
    ts = TimeSeries.from_times_and_values(pd.DatetimeIndex(ts_times), ts_values)
    time_horizon.append(f"{((i + 1) * skip * 10 / 60 / 60):.2f}") # In hours
    y_forecast_list.append(ts)

y_actual_list = [y_actual[TARGETS_clean[0]]] * len(y_forecast_list)

ds = int(92241/skip)
y_actual_list = [y_actual[TARGETS_clean[0]][: ds]] * len(y_forecast_list)

metrics = get_metrics(actual = y_actual[TARGETS_clean[0]][: ds],
                      predicted = y_forecast)
print(metrics)

'''Plotting'''
# =============================================================================
# Plot the time series

# plot_historical_forecast(df = y_actual.pd_dataframe()[: ds],
#                         forecast = y_forecast.pd_dataframe()[: ds-512-63],
#                         lower_percentile = point_selected_values_Low[: ds-512-63],
#                         higher_percentile = point_selected_values_High[: ds-512-63],
#                         target_col = TARGETS_clean[0],
#                         labels = None,
#                         # title = f'Historical Forecast at {prediction_time} minutes',
# )                        

plot_historical_forecast(df = x_actual.pd_dataframe(),
                        forecast = None,
                        lower_percentile = None,
                        higher_percentile = None,
                        target_col = MEAS_COLUMNS[3],
                        labels = None,
                        ylabel = r'Flow rate $[\mathrm{kg/h}]$'
                        # title = f'Historical Forecast at {prediction_time} minutes',
)                        

# make_ae_error_plot(y_actual_list[::5] + [y_actual_list[-1]], 
#                    y_forecast_list[::5] + [y_forecast_list[-1]], 
#                    time_horizon[::5] + [time_horizon[-1]],
#                    Violin=False,
#                    Box=True,
#                    output_Name=f'Chronos_{skip}_Error'
#                    )